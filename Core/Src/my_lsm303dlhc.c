#include <my_lsm303dlhc.h>
#include <string.h>

typedef union {
	uint8_t ui8[6];
	int16_t i16[3];
} union_ui8_ui16;


int mock_value_index = 0;
float mocked_values_x[256] = { 0.0 };
float mocked_values_y[256] = { 0.0 };
float mocked_values_z[256] = { 12.34112545, 2.57507389, 0.72302239, -7.72322543,
		-9.61628568, -1.27698236, 0.86771959, 10.78372983, 5.96604882,
		1.38178531, -4.75913645, -10.3241729, -4.23809424, 0.4775156,
		7.01781306, 9.85023043, 1.46283627, -1.42023032, -9.90338648,
		-7.15001301, 0.08193131, 3.06178613, 12.16535829, 2.39718437,
		1.17144619, -8.26096925, -9.20968256, -1.36453786, 0.54346786,
		11.48344932, 5.05082067, 2.27268906, -5.37521013, -10.17007194,
		-3.86308671, -0.35160386, 8.10315937, 8.77432857, 2.27056372,
		-1.78025962, -10.04288152, -6.59744201, -0.68907257, 3.80967829,
		11.65526212, 2.54553063, 1.38330787, -8.71060635, -8.72337825,
		-1.67432626, 0.52182109, 11.8808955, 4.36171751, 3.06301897,
		-6.02600967, -9.87695451, -3.67082224, -1.02441309, 9.1158465, 7.661341,
		3.21183596, -2.3218281, -10.02111606, -6.11960193, -1.51451804,
		4.74554149, 10.86076871, 3.0055915, 1.33786894, -9.02812312,
		-8.20497561, -2.17602333, 0.80489822, 11.93716357, 3.96619356,
		3.67541205, -6.64783029, -9.47351298, -3.68012099, -1.47505282,
		9.95674557, 6.62021471, 4.1945147, -2.99192324, -9.84022066,
		-5.76326709, -2.31360474, 5.77776692, 9.85964861, 3.73233303,
		1.03957726, -9.18243881, -7.7052195, -2.82051946, 1.36498969,
		11.6467456, 3.90296547, 4.04992299, -7.17980385, -8.99923902,
		-3.89007275, -1.65941129, 10.54354352, 5.7528624, 5.1224085,
		-3.72495147, -9.5179026, -5.56331802, -3.00811248, 6.80531315,
		8.74989844, 4.65461668, 0.51763172, -9.15844792, -7.27302954,
		-3.54472687, 2.14726984, 11.03806975, 4.17822243, 4.14989205,
		-7.56985707, -8.50055786, -4.28012598, -1.55944223, 10.81880048,
		5.14418654, 5.90468865, -4.44915889, -9.08571264, -5.53932714,
		-3.53005803, 7.7275968, 7.64014826, 5.68216291, -0.17687603,
		-8.95849885, -6.95071149, -4.27775511, 3.07516364, 10.17071743,
		4.76502038, 3.96553358, -7.77980883, -8.02628389, -4.81209954,
		-1.18493128, 10.75557238, 4.85376857, 6.46478012, -5.09365502,
		-8.58595653, -5.69364283, -3.8283497, 8.45433833, 6.63902816,
		6.71438833, -0.97596272, -8.60216401, -6.76981608, -4.94785025,
		4.05784238, 9.12959114, 5.60591945, 3.51489385, -7.78910759,
		-7.62284236, -5.43392016, -0.57253821, 10.36004843, 4.91003664,
		6.74785725, -5.59535209, -8.0675539, -6.0111596, -3.87378863, 8.9143992,
		5.84453475, 7.65025153, -1.80140819, -8.12432394, -6.74805062,
		-5.48941872, 4.99911462, 8.01660357, 6.61860657, 2.84208463,
		-7.59684311, -7.32972493, -6.0847197, 0.2177917, 9.67094527, 5.30748282,
		6.72621048, -5.90514049, -7.58124959, -6.4607967, -3.66192695,
		9.06274546, 5.33443859, 8.3981437, -2.57241208, -7.57175294,
		-6.88754566, -5.84944803, 5.80684208, 6.94070171, 7.70395288,
		2.01296516, -7.22183559, -7.17562398, -6.70079337, 1.10869545,
		8.75571712, 6.00720232, 6.40195875, -5.99269598, -7.17464646,
		-6.99854052, -3.21350315, 8.88485593, 5.15867143, 8.88485593,
		-3.21350315, -6.99854052, -7.17464646, -5.99269598, 6.40195875,
		6.00720232, 8.75571712, 1.10869545, -6.70079337, -7.17562398,
		-7.22183559, 2.01296516, 7.70395288, 6.94070171, 5.80684208,
		-5.84944803, -6.88754566, -7.57175294, -2.57241208, 8.3981437,
		5.33443859, 9.06274546, -3.66192695, -6.4607967, -7.58124959,
		-5.90514049, 6.72621048, 5.30748282, 9.67094527, 0.2177917, -6.0847197,
		-7.32972493, -7.59684311, 2.84208463 };

HAL_StatusTypeDef initializeLSM303DHLC(I2C_HandleTypeDef *i2c) {
	HAL_StatusTypeDef ret;

	uint8_t ui_init_params[3][2] = { { CRA_REG_M, CRA_REG_M_CONFIG }, {
	CRB_REG_M, CRB_REG_M_CONFIG }, { MR_REG_M, MR_REG_M_CONFIG } };

	ret = HAL_I2C_IsDeviceReady(i2c, MY_LSM303DLHC_MAG_ADD, 10,
	200);
	if (ret != HAL_OK) {
		return ret;
	}

	ret = HAL_I2C_Master_Transmit(i2c, MY_LSM303DLHC_MAG_ADD, ui_init_params[0],
			2,
			200);
	if (ret != HAL_OK) {
		return ret;
	}

	ret = HAL_I2C_Master_Transmit(i2c, MY_LSM303DLHC_MAG_ADD, ui_init_params[1],
			2,
			200);
	if (ret != HAL_OK) {
		return ret;
	}

	ret = HAL_I2C_Master_Transmit(i2c, MY_LSM303DLHC_MAG_ADD, ui_init_params[2],
			2,
			200);
	if (ret != HAL_OK) {
		return ret;
	}

	return ret;
}

HAL_StatusTypeDef readRawMagnetometerData(I2C_HandleTypeDef *i2c,
		int16_t *i16_raw_response, uint8_t *ui8_buf_response) {
	HAL_StatusTypeDef ret;

	uint8_t reg = OUT_X_H_M;
	uint8_t ui_lsm_response[6];
	union_ui8_ui16 ui8_16_aux;

	ret = HAL_I2C_Master_Transmit(i2c, MY_LSM303DLHC_MAG_ADD, &reg, 1,
	HAL_MAX_DELAY);
	if (ret == HAL_OK) {
		ret = HAL_I2C_Master_Receive(i2c, MY_LSM303DLHC_MAG_ADD,
				ui_lsm_response, 6, HAL_MAX_DELAY);

		if (ret == HAL_OK) {
			ui8_16_aux.ui8[0] = ui_lsm_response[1];
			ui8_16_aux.ui8[1] = ui_lsm_response[0];

			ui8_16_aux.ui8[2] = ui_lsm_response[3];
			ui8_16_aux.ui8[3] = ui_lsm_response[2];

			ui8_16_aux.ui8[4] = ui_lsm_response[5];
			ui8_16_aux.ui8[5] = ui_lsm_response[4];

			memcpy(i16_raw_response, ui8_16_aux.i16, 3);
			memcpy(ui8_buf_response, ui8_16_aux.ui8, 6);
		}
	}

	return ret;
}

HAL_StatusTypeDef readMagnetometerData(I2C_HandleTypeDef *i2c,
		float *f_response) {
	HAL_StatusTypeDef ret;

	int16_t i16_raw_response[3];
	uint8_t ui8_raw_response[6];

	ret = readRawMagnetometerData(i2c, i16_raw_response, ui8_raw_response);
	if (ret == HAL_OK) {

#if MOCK_VALUES == 1
		f_response[0] = mocked_values_x[mock_value_index] * 0.000001;
		f_response[1] = mocked_values_y[mock_value_index] * 0.000001;
		f_response[2] = mocked_values_z[mock_value_index] * 0.000001;

		mock_value_index = (mock_value_index + 1) % MOCK_SIZE;
#else
		// X conversion
		f_response[0] = i16_raw_response[0] / (float) X_Y_GAIN;
		// Z conversion
		f_response[1] = i16_raw_response[1] / (float) Z_GAIN;

		// Y conversion
		f_response[2] = i16_raw_response[2] / (float) X_Y_GAIN;
#endif

	}

	return ret;
}

